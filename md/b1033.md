<h1>1033. 旧键盘打字(20)</h1>

## 题目

> <div id="problemContent">
> <p>
> 旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？
> </p>
> <p><b>
> 输入格式：
> </b></p>
> <p>输入在2行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过10<sup>5</sup>个字符的串。可用的字符包括字母[a-z, A-Z]、数字0-9、以及下划线“_”（代表空格）、“,”、“.”、“-”、“+”（代表上档键）。题目保证第2行输入的文字串非空。
> </p>
> <p>注意：如果上档键坏掉了，那么大写的英文字母无法被打出。
> 
> <p><b>
> 输出格式：
> </b></p>
> <p>
> 在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。</p>
> <b>输入样例：</b><pre>
> 7+IE.
> 7_This_is_a_test.
> </pre>
> <b>输出样例：</b><pre>
> _hs_s_a_tst
> </pre>
> </p></div>

## 思路

这道就是1029题的逆向版，然后复杂了点而已。（但是代码更少了是什么鬼）

- 读取：在记录坏键的时候很多种键，但是都是ASCII字符，因此用一个int[128]数组记录就好了，一视同仁，简单粗暴。
- 输出：第二行是不会有'+'符号的，因此除了大写字母要特殊判断，只要这个键没有坏（数组没有记录），不管是哪一类符号，输出就行了。
- 使用边读取边处理的方式，空间占用降到最低。
- `toupper`函数对非字母字符会返回参数本身，因此记录/查找的时候不必区分字符类型，全都转换成大写。

这种方法比有多少种字符就创建多大的数组去记录要方便的多，代码量极少。

**注意**：第一行可能为空，使用scanf这样跳过空白字符的函数就不行了。我一开始就用的逐字符读取的方法，每次读到换行，一直都没有发觉这一点……

## 代码

[最新代码@github](https://github.com/OliverLew/PAT/blob/master/PATBasic/1033.c)，欢迎交流
```c
#include <stdio.h>
#include <ctype.h>
int main()
{
    char c;
    int bad[128] = {0}; /* record keys are broken or not */
    
    while((c = getchar()) != '\n')      /* read broken keys */
        bad[toupper(c)] = 1;
    
    while((c = getchar()) != '\n')      /* read string and print */
        if(!bad[toupper(c)] && !(isupper(c) && bad['+']))
              putchar(c);
    
    return 0;
}

```