---
layout: post
title:  "1040. 有几个PAT（25）"
categories: PAT-B
tags: [PAT-B]
---
## 题目

> <div id="problemContent">
> <p>
> 字符串APPAPT中包含了两个单词“PAT”，其中第一个PAT是第2位(P),第4位(A),第6位(T)；第二个PAT是第3位(P),第4位(A),第6位(T)。</p>
> <p>现给定字符串，问一共可以形成多少个PAT？</p>
> <p><b>
> 输入格式：
> </b></p>
> <p>输入只有一行，包含一个字符串，长度不超过10<sup>5</sup>，只包含P、A、T三种字母。
> </p>
> <p><b>
> 输出格式：
> </b></p>
> <p>
> 在一行中输出给定字符串中包含多少个PAT。由于结果可能比较大，只输出对1000000007取余数的结果。
> </p>
> <b>输入样例：</b><pre>
> APPAPT
> </pre>
> <b>输出样例：</b><pre>
> 2
> </pre>
> </div>

## 思路

这明明是一道数学题 (-__-)=@))> o<) （这个颜表情好像Hulk打Thor的那一拳哈哈～～）
![](http://upload-images.jianshu.io/upload_images/1664395-bfb0065baac103aa.gif?imageMogr2/auto-orient/strip)

咳咳。。

怎么分析呢？从前向后扫描：
- 每个**A对应的PA组合数量**是A之前**P的数量**，
- 每个**T对应的PAT组合数量**是T之前所有**A对应的PA组合数量**的累加，
- **所有的PAT组合数量**是所有**T对应的PAT组合数量**的累加

。。。懂？。。。

其实看通过率应该是很多人都会的哈。这道题属于典型的90%时间用于思考，10%时间用于码代码的类型。。。。

**然后证明一下这个magic number——1000000007为什么是这个数（大概等于）以及什么时候应该取模：**
我们用有符号32位整型来计数，按照我代码里的变量名：P、PA、PAT。
- P每次自增1，因此最大会达到10^5，不需取模。
- PA每次累加P的值，我们来看一个比较极端的情况：
 - "PAPA ... (共50000对PA) ... PA"，这样记录PA的组合数量，就是
 PA=1 + 2 + 3 + ... + 50000=2500050000，就已经大于int了，因此计算PA应该取模。
- PAT每次累加PA的值，因此两个值都会比较大，必须要取模。累加之后（取模之前）的数会小于2000000013，这个值小于int的最大值2^31-1=2147483647，不会溢出（模取得过大就会在没来得及取模之前就溢出了，我觉得这是关键）。
 - 那用unsigned int呢，PA是不是不需要取模了？我觉得是的。
- 这道题是要检查答案的，用一个素数做模应该有避免巧合答案的考虑。

写完这个发现刘婼的博客 http://www.liuchuo.net/archives/573 也有相关的解释，并且解题思路也不一样，是累加每个A两边P和T的个数之积。

## 代码

[最新代码@github](https://github.com/OliverLew/PAT/blob/master/PATBasic/1040.c)，欢迎交流
```c
#include <stdio.h>

#define LIM 1000000007

int main()
{
    int P = 0, PA = 0, PAT = 0;
    char c;
    
    while((c = getchar()) != '\n')
    {
        if(c == 'P')   P++;
        if(c == 'A')   PA = (PA + P) % LIM;
        if(c == 'T')   PAT = (PAT + PA) % LIM;
    }
    printf("%d", PAT);
    
    return 0;
}

```