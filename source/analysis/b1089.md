2019-01-06 22:03:59 +0800

这道题想复杂的话可以很复杂，我觉得我的思路还是比较简单的。

先分析题意：

> 已知 N 名玩家中有 2 人扮演狼人角色，有 2 人说的不是实话，有狼人撒谎但并不是所有狼人都在撒谎。

其实可以转化为：

- 一个狼人说谎
- 另一个狼人说真话
- 一个好人说谎
- 剩下的N-3的好人都说真话

前三个是特殊情况，由于题目规模(100)比较小，所以可以用暴力遍历的方式。所以我的思路就是：

- 用一个数组记录每个玩家说的话`records`，初始化两个最小狼人编号为`{100, 100}`
- 对两个狼人和说谎的好人设三个变量`m, n, l`，进行三重遍历
  - 按照两个说谎的人转换两个数的符号，循环结束再复原
  - 再一重遍历`i`，检查可能性。检查方法很直观：
    - 说话内容等于假设的好人`|records[i]| != n or l`，那么符号不能为负
    - 说话内容等于假设的狼人`|records[i]| == n or l`，那么符号不能为正
    - 不符合，则标记
  - 如果未被标记（为不可能），比较当前狼人编号`n, l`是否小于已有的最小编号，
    小于则更新
- 输出，如最小编号仍为`{100, 100}`，即为无解


我看到的方法也都是N^4复杂度的，很多用C++的都用到了向量内积，再加三重循环，实际上也是四重循环，当然算内积应该比我的方法更快一些，写起来也更简洁。

最后我的方法时间在200ms上下，供大家参考。
