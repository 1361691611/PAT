<!-- date and tags in the next two lines
2017-05-15 14:47:21 +0800
subsequence, maximum subsequence sum
-->

可以说是经典算法题目之一了，时间复杂度从O(N^3)到O(N)的算法都存在，编程珠玑、算法导论、数据结构和算法分析（C语言描述）这些书里都有谈到。

当然了这些书里的算法只管计算最大子列和（确实这样就太简单了），并没有记录相应头尾元素，还有什么全是负数还要输出整个数列首位元素（这就是为了出题而出题嘛）。但是程序的骨架是不变的。

O(N)复杂度的算法思路是：记录当前非负子列和和目前最大子列和，若前者变成了负数，便将其重置，直到遍历整个数组。这道题有一个要求：
> In case that the maximum subsequence is not unique, output the one with the smallest indices i and j 

需要索引最小的子列，这就要在判断条件上有精细的控制。要使得开头索引最小，就要将之前可能存在子列和为0的包含进来，而结尾索引也要最小，就要将之后可能存在子列和为0的排除，如：
2 -2 3 4 -5 5
要选取前4个，而不能包括后2个。
