2017-05-04 22:00:31 +0800

又是一道数学题。
解题的代码很少，不过在下面的分析中还加入了浮点型数据精度的分析，虽然不是必要的。

- 先计算出数列中每一个元素在所有片段和中被包含的次数：
 
 每一个包含a[i]的片段需要在a[i]左侧（包含a[i]）和a[i]右侧（也包含a[i]）各选取一个端点。我们使用0开始的计数。左侧端点选取可能有i+1种，右侧端点选取可能有N-i种。

 因此包含a[i]的片段和一共有(i+1)(N-i)种，做一个加权求和即可求出片段和：![](http://latex.codecogs.com/svg.latex?\sum_{i=0}^{N-1}(i+1)(N-i)a_i)
- **严谨起见的分析：** 最大可能的片段和（我们要用的变量类型）：

 令N=100000，任意i都有a[i]=1.0，此时的片段和为

 ![](http://latex.codecogs.com/svg.latex?\sum_{i=1}^{N}i(N-i+1)\\=-\sum_{i=1}^{N}i^2+(N+1)\sum_{i=1}^{N}i\\=-\frac{N(N+1)(2N+1)}{6}+\frac{N(N+1)^2}{2}\\=\frac{1}{6}N(N+1)(N+2))

 这个数约等于1.67e14，题目要求精度达到小数点后2位，即相当于**相对误差最多为6e-17**。然后我们看一下不同浮点型[(Wiki)](https://en.wikipedia.org/wiki/Floating-point_arithmetic)的精度：

 - 单精度浮点的误差：尾数部分有23位，精度为1.2e-7；
 - 双精度浮点的误差：尾数部分有52位，精度为2.2e-16；
 - 扩展精度的浮点型的误差：尾数部分有63位，精度为1.1e-19；

 可以看出单精度浮点是绝对不能用的，虽然双精度浮点的误差略大于上面分析的结果，但是我觉得PAT不会（事实上也没有）挖这个坑，所以用`double`类型的会过（我没有试过`float`）。如果要写更加严谨的代码，应使用`long double`。

- 还有一个问题，看了[这篇博客](http://blog.csdn.net/luoluozlb/article/details/51532281)才发现，同样是数据范围的问题。(i+1)(N-i)最大值约为N^2/4也就是2.5e9，32位有符号整型`int`的最大值是2^31-1，约为2e9，先乘这两个整数可能会发生溢出。那篇博客说在求和时先算这两个整数的乘积会有测试点过不去，就是测试点在测试N很大的情况。
