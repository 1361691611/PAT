这道题写起来有一个小点令我很头疼，不过总体来说还是很简单。

整体思路就是，循环：
- 把A反转，得到B
- 相加A和B，得到C
- 判断C是否是回文数

为了包含进A本身就是回文数的特殊情况，可以在第一步判断A是否是回文数。

然后就是具体的每一步的实现：
- 翻转一个数，`reverseAtoB`，将A翻转，结果存储在B中，实现很简单。
  - 不过要说一点，我并没有每次在B字符串的末尾加上`'\0'`，是因为我初始化全为`\0`，并且此题的情况中字符串不会缩短，因此不加不会有错误，但是在更广泛的用途中极有可能产生bug。
- 两数相加，`addBtoA`，将A和B相加，结果存储在A中，这个就是让我有点头疼的。由于题目要求数字只能用字符串存储，那么原地做加法的话，最后如果要进位，前面就没有位置了啊。最后还是硬着头皮暴力地把所有位后移（使用了`memmove`函数），因此看起来并不是很简洁。
- 判断是否是回文数，`isPalindromicNumber`，也很简单。

简单的说一下为什么字符串长度用1011：
初始数字最多1000位，每次翻转相加，对于任何数都不会增大10倍以上（如10009+90001=100010，很接近10倍），因此10次之内得到的结果绝对不会超出1010位，因此字符串就用了char[1011]。
