<!-- date and tags in the next two lines
2017-04-14 14:31:23 +0800
string processing
-->

先理解一下答案正确的条件：

1. 字符串只能包含`'P', 'A', 'T'`三种字符，简单，有其它字符就是错误的了。
2. xPATx格式的是正确的。这个条件需要正确理解，当时就是在这条上想错了，结果好多次没有通过。**两个x是代指相同的字符串**。（有些人包括我理解错的原因大概是按照正则表达式的`*`去理解这里的x了）
3. aPbTc正确，aPbATca也正确。翻译一下，就是P和T中间每增加一个A，需要将P之前的内容复制到字符串末尾，得到的新字符串就也是正确的。

结合这三点，总结起来就是：
- **只存在`'P', 'A', 'T'`三种字符；**
- **`'P', 'T'`只能出现一次并且按照该顺序先后出现；**
- **P&T之间不能没有A；**
- **T之后A的数量 = P之前A的数量 × P&T中间A的数量。**

代码实现：

* 使用三个数`count[3]`记录P之前，P&T之间，T之后A的数量。
* 为了检测`'P', 'T'`的出现及次序，使用一个标记变量`pos`：

  * 其值在出现P之前为0（使用count[0]记录P之前的A）
  * 只有在出现P且其值为0时，将值变为1（使用count[1]记录P&T之间的A）
  * 只有在出现T且其值为1时，将其变为2（使用count[2]记录T之后的A）

 这样即可保证除此之外出现非`'A'`字符的情况都是不符合要求的。pos顺便还能作为count[]的索引。
