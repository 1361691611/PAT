---
layout: post
date: 2018-12-28 00:49:00 +0800
title:  "PAT Basic 1094. 谷歌的招聘 (C语言实现)"
categories: Basic
tags: [PAT-B]
permalink: Basic/1094.html
---

## 题目

2004 年 7 月，谷歌在硅谷的 101 号公路边竖立了一块巨大的广告牌（如下图）用于招聘。内容超级简单，就是一个以 .com
结尾的网址，而前面的网址是一个 10 位素数，这个素数是自然常数 e 中最早出现的 10
位连续数字。能找出这个素数的人，就可以通过访问谷歌的这个网站进入招聘流程的下一步。

![prime.jpg](https://images.ptausercontent.com/57148679-d574-4f49-b048-775c6c07791c.jpg)

自然常数 e 是一个著名的超越数，前面若干位写出来是这样的：e =
2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642
**7427466391** 932003059921... 其中粗体标出的 10 位数就是答案。

本题要求你编程解决一个更通用的问题：从任一给定的长度为 L 的数字中，找出最早出现的 K 位连续数字所组成的素数。

### 输入格式：

输入在第一行给出 2 个正整数，分别是 L（不超过 1000 的正整数，为数字长度）和 K（小于 10 的正整数）。接下来一行给出一个长度为 L 的正整数
N。

### 输出格式：

在一行中输出 N 中最早出现的 K 位连续数字所组成的素数。如果这样的素数不存在，则输出 `404`。注意，原始数字中的前导零也计算在位数之内。例如在
200236 中找 4 位素数，0023 算是解；但第一位 2 不能被当成 0002 输出，因为在原始数字中不存在这个 2 的前导零。

### 输入样例 1：

    
    
    20 5
    23654987725541023819
    

### 输出样例 1：

    
    
    49877
    

### 输入样例 2：

    
    
    10 3
    2468024680
    

### 输出样例 2：

    
    
    404
    



## 思路

考察素数相关的题目。

检查素数函数惯例，不多说。

**数学相关：**
题目要检查每K位数字是否是素数，鉴于K是小于10的，所以32位int是可以装得下的。当然，严谨的话，在下面的代码中还需要考虑`i*i`是不是够用，其实也是够的。

具体方法，我使用了一个char[10]数组，每一次从字符串中使用`strncpy`复制K个字符过来，用`atoi`转化为整型，然后就可以判断了。并且这样在输出时直接输出这个短字符串，也不需要考虑前面补0的问题，比较方便。

## 代码

[最新代码@github](https://github.com/OliverLew/PAT/blob/master/PATBasic/1094.c)，欢迎交流
```c
{% raw %}#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int iPrime(int n)
{
    if(n < 2)
        return 0;
    for(int i = 2; i * i <= n; i++)
        if(n % i == 0)
            return 0;
    return 1;
}

int main()
{
    char N[1000], n[10] = {0};
    int L, K;

    scanf("%d %d %s", &L, &K, N);  /* L == strlen(N) */
    for(int i = 0; i <= L - K; i++)
    {
        strncpy(n, N + i, K);
        if(iPrime(atoi(n)))
        {
            printf("%s", n);
            return 0;
        }
    }

    printf("404");
    return 0;
}
{% endraw %}
```