---
layout: post
date: 2017-05-05 00:17:48 +0800
title:  "PAT Basic 1035. 插入与归并(25) (C语言实现)"
categories: Basic
tags: []
permalink: Basic/1035.html
---

## 题目

{% raw %}<div id="problemContent">
<p>根据维基百科的定义：</p>
<p><b>插入排序</b>是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。</p>
<p>
<b>归并排序</b>进行如下迭代操作：首先将原始序列看成N个只包含1个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下1个有序的序列。</p>
<p>现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？</p>
<p><b>
输入格式：
</b></p>
<p>
输入在第一行给出正整数N (&lt;=100)；随后一行给出原始序列的N个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。
</p>
<p><b>
输出格式：
</b></p>
首先在第1行中输出“Insertion Sort”表示插入排序、或“Merge Sort”表示归并排序；然后在第2行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行末不得有多余空格。
<p>
</p>
<b>输入样例1：</b><pre>
10
3 1 2 8 7 5 9 4 6 0
1 2 3 7 8 5 9 4 6 0
</pre>
<b>输出样例1：</b><pre>
Insertion Sort
1 2 3 5 7 8 9 4 6 0
</pre>
<b>输入样例2：</b><pre>
10
3 1 2 8 7 5 9 4 0 6
1 3 2 8 5 7 4 9 0 6
</pre>
<b>输出样例2：</b><pre>
Merge Sort
1 2 3 8 4 5 7 9 0 6
</pre>
</div>{% endraw %}

## 思路

这道题是我唯一看了几乎网上所有热门博客都没有发现自己错在哪的一道题，提交了10遍啊～差点绝望。最后乖乖地按照普遍做法改写了代码，终于过了。

题中说
> 题目保证每组测试的结果是唯一的。

这应该有两点保证：
- 一定能区分插入排序和归并排序
- 一定能确定排序的步数，不会产生某一步排序没有任何改变的情况

判断哪种排序方法
- 插入排序：
从后向前找到和原始数组不同的元素，验证此元素之前是否为排好序的，如果是排好的，则是插入排序，下一步将第一个相同的元素插入排序
- 归并排序：
从最初的数组模拟一步一步的归并，直至和中间序列相同，再向下进行一步

## 代码

[最新代码@github](https://github.com/OliverLew/PAT/blob/master/PATBasic/1035.c)，欢迎交流
```c
{% raw %}#include <stdio.h>
#include <stdlib.h>

int comp(const void *a, const void *b)
{ 
    return *(int*)a - *(int*)b;
}

int main()
{
    int N, origin[100], halfsort[100], i, j, length;
    scanf("%d", &N);
    for(int i = 0; i < N; i++) scanf("%d", origin + i);
    for(int i = 0; i < N; i++) scanf("%d", halfsort + i);
    
    /* if it is insertion sort, return sorted length if yes, zero otherwise */
    for(i = 0; i < N - 1 && halfsort[i] <= halfsort[i + 1]; i++) ;
    for(length = ++i; i < N && halfsort[i] == origin[i]; i++) ;
    length = i == N ? length + 1 : 0;
    
    if(length)                  /* insertion sort */
    {
        puts("Insertion Sort");
        qsort(origin, length, sizeof(int), comp);
    }
    else                        /* merge sort, operate on the original array */
    {
        puts("Merge Sort");
        for(length = 1, i = 0; i < N && length <= N; length *= 2)
        {
            /* i == N means identical, also breaks the outer 'for' loop */
            for(i = 0; i < N && origin[i] == halfsort[i]; i++) ; 
            for(j = 0; j < N / length; j++)
                qsort(origin + j * length, length, sizeof(int), comp);
            qsort(origin + j * length, N % length, sizeof(int), comp);
        }
    }
    
    for(int i = 0; i < N; i++) 
        printf("%d%c", origin[i], i == N - 1 ? '\n' : ' ');
    
    return 0;
}
{% endraw %}
```