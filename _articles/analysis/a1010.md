<!-- date and tags in the next two lines
2017-05-20 22:08:19 +0800
numbers, radix, number notations
-->

一开始以为数字是0-9a-z，那进制最多就是36，结果一小半都错。看了一下别人的方法，才知道进制并没有任何限制。

几个要点：
- 用二分查找法（binary search）。因为radix范围是2～LLONG_MAX，逐一遍历肯定是算到地老天荒的。（LLONG_MAX是long long能存储的最大值，定义在头文件limits.h中）
- 运算中过大的数的处理。如果预计计算结果会大于long long int范围，就返回一个代表溢出的结果（如-1）。
- 关于“If the solution is not unique, output the smallest possible radix.”，这只能发生在未知进制的数只有一位的情况下，它在任何进制下的值都是一样的，这样如果它等于已知数，最小可能进制就是这个数加1，否则就无解。

当然我在处理溢出的时候并没有像大多数人（我也不知道是不是大多数，因为10篇博客有8篇都是雷同的）将结果和已知数对比，而是和LLONG_MAX对比，当然不能直接将结果算出来了，具体看我的代码base10函数。
另外由于我是在LLONG_MAX以内查找，因此二分查找第一次求平均时就是LLONG_MAX加一个数除以二，这里就溢出了，所以这里也做了防溢出。具体在binsearch函数。

P.S. 其实这道题用long long类型存储在严格的分析下也是不够的，比如说最大的情况（worst scenario）：所给的数是zzzzzzzzzz，它的进制是2^31-1^（INT_MAX，既然没限制，那么这就是最小合理上限），另一个数是10，那后者的进制可以是前者的10进制的值，约是：3.5*10^85^，远远大于C语言内置数据类型的容量。我也想过实现下满足这样苛刻要求的方法，用多个int表示一个超大的数，但是运算上比较麻烦，没个200行写不下，所以就暂时按照大多数人的思路写了，反正能AC╭(╯^╰)╮
