### 我的PAT系列文章更新重心已移至Github，欢迎来看PAT题解的小伙伴请到[Github Pages](https://oliverlew.github.io/PAT)浏览最新内容([本篇文章链接](https://oliverlew.github.io/PAT/Basic/1001.html))。此处文章目前已更新至与Github Pages同步。欢迎star我的[repo](https://github.com/OliverLew/PAT)。

## 题目

卡拉兹(Callatz)猜想：

对任何一个正整数 $n$ ，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 $(3n+1)$ 砍掉一半。这样一直反复砍下去，最后一定在某一步得到
$n=1$ 。卡拉兹在 1950
年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 $(3n+1)$
，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……

我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 $n$ ，简单地数一下，需要多少步（砍几下）才能得到 $n=1$ ？

### 输入格式：

每个测试输入包含 1 个测试用例，即给出正整数 $n$ 的值。

### 输出格式：

输出从 $n$ 计算到 1 需要的步数。

### 输入样例：

    
    
    3
    

### 输出样例：

    
    
    5
    



## 思路


很简单的一道题，读取数字后按照规则计算，记录计算次数即可。


## 代码

[最新代码@github](https://github.com/OliverLew/PAT/blob/master/PATBasic/1001.c)，欢迎交流
```c
#include <stdio.h>

int main()
{
    int number, steps;
    scanf("%d", &number);

    for(steps = 0; number != 1; steps++)
        if(number % 2 == 0)
            number /= 2;
        else
            number = (3 * number + 1) / 2;

    printf("%d", steps);

    return 0;
}
```