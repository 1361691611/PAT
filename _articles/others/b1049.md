### 我的PAT系列文章更新重心已移至Github，欢迎来看PAT题解的小伙伴请到[Github Pages](https://oliverlew.github.io/PAT)浏览最新内容([本篇文章链接](https://oliverlew.github.io/PAT/Basic/1049.html))。此处文章目前已更新至与Github Pages同步。欢迎star我的[repo](https://github.com/OliverLew/PAT)。

## 题目

给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 { 0.1, 0.2, 0.3, 0.4 }，我们有 (0.1) (0.1,
0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4)
(0.3) (0.3, 0.4) (0.4) 这 10 个片段。

给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9
+ 0.3 + 0.7 + 0.4 = 5.0。

### 输入格式：

输入第一行给出一个不超过 $10^5$ 的正整数 $N$ ，表示数列中数的个数，第二行给出 $N $ 个不超过 1.0
的正数，是数列中的数，其间以空格分隔。

### 输出格式：

在一行中输出该序列所有片段包含的数之和，精确到小数点后 2 位。

### 输入样例：

    
    
    4
    0.1 0.2 0.3 0.4
    

### 输出样例：

    
    
    5.00
    



## 思路


又是一道数学题。
解题的代码很少，不过在下面的分析中还加入了浮点型数据精度的分析，虽然不是必要的。

- 先计算出数列中每一个元素在所有片段和中被包含的次数：

  每一个包含a[i]的片段需要在a[i]左侧（包含a[i]）和a[i]右侧（也包含a[i]）各选取一个端点。我们使用0开始的计数。左侧端点选取可能有i+1种，右侧端点选取可能有N-i种。

  因此包含a[i]的片段和一共有(i+1)(N-i)种，做一个加权求和即可求出片段和：

  $$
    \sum_{i=0}^{N-1}(i+1)(N-i)a_i
  $$

- **严谨起见的分析：** 最大可能的片段和（我们要用的变量类型）：

  令N=100000，任意i都有a[i]=1.0，此时的片段和为

  $$
    \sum_{i=1}^{N}i(N-i+1)=\frac{1}{6}N(N+1)(N+2))
  $$

  这个数约等于1.67e14，题目要求精度达到小数点后2位，即相当于**相对误差最多为6e-17**。然后我们看一下不同浮点型[(Wiki)](https://en.wikipedia.org/wiki/Floating-point_arithmetic)的精度：

  - 单精度浮点的误差：尾数部分有23位，精度为1.2e-7；
  - 双精度浮点的误差：尾数部分有52位，精度为2.2e-16；
  - 扩展精度的浮点型的误差：尾数部分有63位，精度为1.1e-19；

  可以看出单精度浮点是绝对不能用的，虽然双精度浮点的误差略大于上面分析的结果，但是我觉得PAT不会（事实上也没有）挖这个坑，所以用`double`类型的会过（我没有试过`float`）。如果要写更加严谨的代码，应使用`long double`。

- 还有一个问题，看了[这篇博客](http://blog.csdn.net/luoluozlb/article/details/51532281)才发现，同样是数据范围的问题。`(i+1)(N-i)`最大值约为`N^2/4`也就是`2.5e9`，32位有符号整型`int`的最大值是`2^31-1`，约为`2e9`，先乘这两个整数可能会发生溢出。那篇博客说在求和时先算这两个整数的乘积会有测试点过不去，就是测试点在测试N很大的情况。

## 代码

[最新代码@github](https://github.com/OliverLew/PAT/blob/master/PATBasic/1049.c)，欢迎交流
```c
#include <stdio.h>

int main()
{
    int N;
    double ai, sum = 0;

    scanf("%d", &N);
    for(int i = 0; i < N; i++)
    {
        scanf("%lf", &ai);
        /* ai is put at the beginning to avoid overflow */
        sum += ai * (i + 1) * (N - i);
    }
    printf("%.2lf", sum);

    return 0;
}
```