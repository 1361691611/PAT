# PAT Basic 1024. 科学计数法 (20) (C语言实现)

### 我的PAT系列文章更新重心已移至Github，欢迎来看PAT题解的小伙伴请到[Github Pages](https://oliverlew.github.io/PAT)浏览最新内容([本篇文章链接](https://oliverlew.github.io/PAT/Basic/1024.html))。此处文章目前已更新至与Github Pages同步。欢迎star我的[repo](https://github.com/OliverLew/PAT)。

## 题目

科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式
[+-][1-9]`.`[0-9]+E[+-][0-9]+，即数字的整数部分只有 1 位，小数部分至少有 1
位，该数字及其指数部分的正负号即使对正数也必定明确给出。

现以科学计数法的格式给出实数 $A$ ，请编写程序按普通数字表示法输出 $A$ ，并保证所有有效位都被保留。

### 输入格式：

每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 $A$ 。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。

### 输出格式：

对每个测试用例，在一行中按普通数字表示法输出 $A$ ，并保证所有有效位都被保留，包括末尾的 0。

### 输入样例 1：

    
    
    +1.23400E-03
    

### 输出样例 1：

    
    
    0.00123400
    

### 输入样例 2：

    
    
    -1.2E+10
    

### 输出样例 2：

    
    
    -12000000000
    



## 思路


很有意思的一个题目，让我们完成一个解析科学计数法的小功能。

读取的时候用到了一种格式化字符串```%[^...]```，这和`%s`类似，不过会终止于```[^]```里面的字符，而不是空白字符，利用这个可以简单的读取'E'前后的两个数。

解析时考虑三种情况：
- 指数大于（等于）0，
 - 指数大于（等于）小数位数，末尾补0，不输出小数点，
 - 指数小于小数位数，要在中间输出小数点，
- 指数小于0，在前面补0，小数点前移至第一个0后面。

## 代码

[最新代码@github](https://github.com/OliverLew/PAT/blob/master/PATBasic/1024.c)，欢迎交流
```c
#include <stdio.h>

int main()
{
    int exponent;    /* the exponent part */
    char line[10000], *p = line;
    scanf("%[^E]E%d", line, &exponent);

    if(*p++ == '-') putchar('-');       /* no print if it's '+' */
    if(exponent >= 0)           /* print '.' later or add zeros in the end */
    {
        putchar(*p);
        for(p += 2; exponent; exponent--)    /* print the integer part */
            putchar(*p ? *p++ : '0');
        if(*p)                               /* there is still fraction part */
        {
            putchar('.');
            while(*p) putchar(*p++);
        }
    }
    if(exponent < 0)            /* add exponent zeros in the beginning */
    {
        printf("0.");
        for(exponent++; exponent; exponent++)       /* add zeros */
            putchar('0');
        for(; *p; p++) if(*p != '.') putchar(*p);   /* the rest */
    }

    return 0;
}
```