### 我的PAT系列文章更新重心已移至Github，欢迎来看PAT题解的小伙伴请到[Github Pages](https://oliverlew.github.io/PAT)浏览最新内容([本篇文章链接](https://oliverlew.github.io/PAT/Basic/1040.html))。此处文章目前已更新至与Github Pages同步。欢迎star我的[repo](https://github.com/OliverLew/PAT)。

## 题目

字符串 `APPAPT` 中包含了两个单词 `PAT`，其中第一个 `PAT` 是第 2 位(`P`)，第 4 位(`A`)，第 6 位(`T`)；第二个
`PAT` 是第 3 位(`P`)，第 4 位(`A`)，第 6 位(`T`)。

现给定字符串，问一共可以形成多少个 `PAT`？

### 输入格式：

输入只有一行，包含一个字符串，长度不超过 $10^5$ ，只包含 `P`、`A`、`T` 三种字母。

### 输出格式：

在一行中输出给定字符串中包含多少个 `PAT`。由于结果可能比较大，只输出对 1000000007 取余数的结果。

### 输入样例：

    
    
    APPAPT
    

### 输出样例：

    
    
    2
    



## 思路


这明明是一道数学题。。

怎么分析呢？从前向后扫描：
- 每个**A对应的PA组合数量**是A之前**P的数量**，
- 每个**T对应的PAT组合数量**是T之前所有**A对应的PA组合数量**的累加，
- **所有的PAT组合数量**是所有**T对应的PAT组合数量**的累加

。。。懂？。。。

其实看通过率应该是很多人都会的哈。这道题属于典型的90%时间用于思考，10%时间用于码代码的类型。。。。

**然后证明一下这个magic number——1000000007为什么是这个数（大概等于）以及什么时候应该取模：**
我们用有符号32位整型来计数，按照我代码里的变量名：P、PA、PAT。
- P每次自增1，因此最大会达到$10^5$，不需取模。
- PA每次累加P的值，我们来看一个比较极端的情况：
  - `"PAPA ... (共50000对PA) ... PA"`，这样记录PA的组合数量，就是
  PA=$\sum_{i=1}^{50000}i=2500050000$，就已经大于int了，因此计算PA应该取模。
- PAT每次累加PA的值，因此两个值都会比较大，必须要取模。累加之后的数会小于2000000013，这个值小于int的最大值$2^{31}-1=2147483647$，不会溢出（模取得过大就会在没来得及取模之前就溢出了，我觉得这是关键）。
  - 那用unsigned int呢，PA是不是不需要取模了？我觉得是的。
- 这道题是要检查答案的，用一个素数做模应该有避免巧合答案的考虑。

写完这个发现博客 [http://www.liuchuo.net/archives/573](http://www.liuchuo.net/archives/573) 也有相关的解释，并且解题思路也不一样，是累加每个A两边P和T的个数之积。

## 代码

[最新代码@github](https://github.com/OliverLew/PAT/blob/master/PATBasic/1040.c)，欢迎交流
```c
#include <stdio.h>

#define LIM 1000000007

int main()
{
    int P = 0, PA = 0, PAT = 0;
    char c;

    while((c = getchar()) != '\n')
    {
        if(c == 'P')   P++;
        if(c == 'A')   PA = (PA + P) % LIM;
        if(c == 'T')   PAT = (PAT + PA) % LIM;
    }
    printf("%d", PAT);

    return 0;
}
```