---
layout: post
date: 2017-05-04 22:00:31 +0800
title:  "PAT Basic 1049. 数列的片段和(20) (C语言实现)"
categories: PAT-B
tags: [PAT-B]
---

## 题目

<div id="problemContent">
<p>
给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列{0.1, 0.2, 0.3, 0.4}，我们有(0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这10个片段。</p>
<p>给定正整数数列，求出全部片段包含的所有的数之和。如本例中10个片段总和是0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0。</p>
<p><b>
输入格式：
</b></p>
<p>
输入第一行给出一个不超过10<sup>5</sup>的正整数N，表示数列中数的个数，第二行给出N个不超过1.0的正数，是数列中的数，其间以空格分隔。
</p>
<p><b>
输出格式：
</b></p>
<p>
在一行中输出该序列所有片段包含的数之和，精确到小数点后2位。
</p>
<b>输入样例：</b><pre>
4
0.1 0.2 0.3 0.4 
</pre>
<b>输出样例：</b><pre>
5.00
</pre>
</div>

## 思路

又是一道数学题。
解题的代码很少，不过在下面的分析中还加入了浮点型数据精度的分析，虽然不是必要的。

- 先计算出数列中每一个元素在所有片段和中被包含的次数：
 
 每一个包含a[i]的片段需要在a[i]左侧（包含a[i]）和a[i]右侧（也包含a[i]）各选取一个端点。我们使用0开始的计数。左侧端点选取可能有i+1种，右侧端点选取可能有N-i种。

 因此包含a[i]的片段和一共有(i+1)(N-i)种，做一个加权求和即可求出片段和：![](http://latex.codecogs.com/svg.latex?\sum_{i=0}^{N-1}(i+1)(N-i)a_i)
- **严谨起见的分析：** 最大可能的片段和（我们要用的变量类型）：

 令N=100000，任意i都有a[i]=1.0，此时的片段和为

 ![](http://latex.codecogs.com/svg.latex?\sum_{i=1}^{N}i(N-i+1)\\=-\sum_{i=1}^{N}i^2+(N+1)\sum_{i=1}^{N}i\\=-\frac{N(N+1)(2N+1)}{6}+\frac{N(N+1)^2}{2}\\=\frac{1}{6}N(N+1)(N+2))

 这个数约等于1.67e14，题目要求精度达到小数点后2位，即相当于**相对误差最多为6e-17**。然后我们看一下不同浮点型[(Wiki)](https://en.wikipedia.org/wiki/Floating-point_arithmetic)的精度：

 - 单精度浮点的误差：尾数部分有23位，精度为1.2e-7；
 - 双精度浮点的误差：尾数部分有52位，精度为2.2e-16；
 - 扩展精度的浮点型的误差：尾数部分有63位，精度为1.1e-19；

 可以看出单精度浮点是绝对不能用的，虽然双精度浮点的误差略大于上面分析的结果，但是我觉得PAT不会（事实上也没有）挖这个坑，所以用`double`类型的会过（我没有试过`float`）。如果要写更加严谨的代码，应使用`long double`。

- 还有一个问题，看了[这篇博客](http://blog.csdn.net/luoluozlb/article/details/51532281)才发现，同样是数据范围的问题。(i+1)(N-i)最大值约为N^2/4也就是2.5e9，32位有符号整型`int`的最大值是2^31-1，约为2e9，先乘这两个整数可能会发生溢出。那篇博客说在求和时先算这两个整数的乘积会有测试点过不去，就是测试点在测试N很大的情况。

## 代码

[最新代码@github](https://github.com/OliverLew/PAT/blob/master/PATBasic/1049.c)，欢迎交流
```c
#include <stdio.h>

int main()
{
    int N;
    double ai, sum = 0;
    
    scanf("%d", &N);
    for(int i = 0; i < N; i++)
    {
        scanf("%lf", &ai);
        /* ai is put at the beginning to avoid overflow */
        sum += ai * (i + 1) * (N - i);
    }
    printf("%.2lf", sum);
    
    return 0;
}

```