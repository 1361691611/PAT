---
layout: post
date: 2017-05-05 14:48:44 +0800
title:  "1068. 万绿丛中一点红(20)"
categories: PAT-B
tags: [PAT-B]
---

## 题目

> <div id="problemContent">
> <p>对于计算机而言，颜色不过是像素点对应的一个24位的数值。现给定一幅分辨率为MxN的画，要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点，并且该点的颜色与其周围8个相邻像素的颜色差充分大。
> </p>
> <p><b>
> 输入格式：
> </b></p>
> <p>
> 输入第一行给出三个正整数，分别是M和N（&lt;= 1000），即图像的分辨率；以及TOL，是所求像素点与相邻点的颜色差阈值，色差超过TOL的点才被考虑。随后N行，每行给出M个像素的颜色值，范围在[0, 2<sup>24</sup>)内。所有同行数字间用空格或TAB分开。
> </p>
> <p><b>
> 输出格式：
> </b></p>
> <p>
> 在一行中按照“(x, y): color”的格式输出所求像素点的位置以及颜色值，其中位置x和y分别是该像素在图像矩阵中的列、行编号（从1开始编号）。如果这样的点不唯一，则输出“Not Unique”；如果这样的点不存在，则输出“Not Exist”。
> </p>
> <b>输入样例1：</b><pre>
> 8 6 200
> 0 	 0 	  0 	   0	    0 	     0 	      0        0
> 65280 	 65280    65280    16711479 65280    65280    65280    65280
> 16711479 65280    65280    65280    16711680 65280    65280    65280
> 65280 	 65280    65280    65280    65280    65280    165280   165280
> 65280 	 65280 	  16777015 65280    65280    165280   65480    165280
> 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215
> </pre>
> <b>输出样例1：</b><pre>
> (5, 3): 16711680
> </pre>
> <b>输入样例2：</b><pre>
> 4 5 2
> 0 0 0 0
> 0 0 3 0
> 0 0 0 0
> 0 5 0 0
> 0 0 0 0
> </pre>
> <b>输出样例2：</b><pre>
> Not Unique
> </pre>
> <b>输入样例3：</b><pre>
> 3 3 5
> 1 2 3
> 3 4 5
> 5 6 7
> </pre>
> <b>输出样例3：</b><pre>
> Not Exist
> </pre>
> </div>

## 思路

在这道题上我好像想多了，当然也有可能陈越姥姥想少了（怎么可能，不可能的）。

首先就是，**“颜色差”** 是什么？网上其他人的做法99%（可能100%）都是直接把两个颜色的值相减，结果的整数就是颜色差了。
而我参考了[Wiki: Color difference](https://en.wikipedia.org/wiki/Color_difference)，
将(R, G, B)三维颜色空间的“距离”作为颜色差，这也是很合理的。比如65280，也就是#00FF00，是绿色，
而65279，#00FEFF，是青色，两者在整数大小上相差1，但是颜色有很大区别。幸好（或许也是不幸）在测试用例没有使用上面这样的例子，
我的测试结果和大家都是一样的。

然后就是大家都遇到的难(keng)点：

- 第一个难(keng)点：

> 要求你找出万绿丛中的一点红，即有独一无二颜色的那个像素点

  解读：需要这个颜色在整幅图中只出现一次。

- 第二个难(keng)点：虽然题目说

> 该点的颜色与其周围**8个**相邻像素的颜色差充分大。

  但是题目还是设置了处于边界的满足“条件”的点，所以说这又是一个题目叙述不清楚的案例（好多受害者）。

  应对这个问题目前看到的代码中有两个解决方案，一是加入边界特殊情况的检测，二是在题目数据的周围加一圈0。
  第一个方案没有问题。第二个方案我觉得是有问题的，如图片的**左上角**有这样的数据：
```
#000001 #0000FF ......
#0000FF #0000FF ......
......  ......  ......
```
  假设颜色#000001在图片只出现了这一次，这样这个点应该符合要求。但是周围加上0就变成了
```
#000000 #000000 #000000 ......
#000000 #000001 #0000FF ......
#000000 #0000FF #0000FF ......
......  ......  ......  ......
```
  不管颜色差是怎么算的，这个中间的`#000001`都是不能被检测出来的。但是又很幸运地，我看使用这个方法的代码也都通过了。
  我能说什么呢 :)

P.S.

**关于代码优化**：这个代码运行时间好长（160+ms），应该是判断颜色唯一太耗时了，相当于O(N^2\*M^2)，
或许改为用另一个排序好的列表查找会好很多（预计时间复杂度为M\*N\*log(M\*N)）。

**更新：上面的判断竟然是错的**，我在本地测试了上述方案，使用最多的数据1000*1000，排序加查找竟然比原来的方案耗时多一个数量级
～～～o(>﹏<)o。之前的方案从文件读取用了0.2秒，但是查找只用了0.04秒（其中iUnique函数只有0.02秒！）。
新的方案qsort用了0.2秒，查找（使用了bsearch）用了0.3秒！这不科学 (ㄒoㄒ) （难道是被stdlib坑了？）
（证明瓶颈在数据读取上，那运行时间长的锅我就不背了）

## 代码

[最新代码@github](https://github.com/OliverLew/PAT/blob/master/PATBasic/1068.c)，欢迎交流
```c
#include <stdio.h>

#define SQR(X) ((X)*(X))
#define R(COLOR) ((COLOR & 0XFF0000) >> 16)
#define G(COLOR) ((COLOR & 0X00FF00) >> 8)
#define B(COLOR) (COLOR & 0X0000FF)
#define D(C1, C2) (SQR(R(C1) - R(C2)) + SQR(G(C1) - G(C2)) +  SQR(B(C1) - B(C2)))

int iUnique(int array[][1000], int x, int y, int x0, int y0)
{
    for(int i = 0; i < x; i++)
        for(int j = 0; j < y; j++)
            if(array[i][j] == array[x0][y0] && i != x0 && j != y0)
                return 0;
    return 1;
}

int main()
{
    int M, N, TOL;
    scanf("%d %d %d", &M, &N, &TOL);
    
    int fig[1000][1000];
    for(int i = 0; i < N; i++)
        for(int j = 0; j < M; j++)
            scanf("%d", &fig[i][j]);
    
    int count = 0, M0, N0;
    for(int i = 0; i < N; i ++)
        for (int j = 0; j < M; j++)
            if((i ==   0   ? 1 : D(fig[i][j], fig[i - 1][j - 1]) > SQR(TOL))
            && (i ==   0   ? 1 : D(fig[i][j], fig[i - 1][j    ]) > SQR(TOL))
            && (i ==   0   ? 1 : D(fig[i][j], fig[i - 1][j + 1]) > SQR(TOL))
            && (j ==   0   ? 1 : D(fig[i][j], fig[i    ][j - 1]) > SQR(TOL))
            && (j == M - 1 ? 1 : D(fig[i][j], fig[i    ][j + 1]) > SQR(TOL))
            && (i == N - 1 ? 1 : D(fig[i][j], fig[i + 1][j - 1]) > SQR(TOL))
            && (i == N - 1 ? 1 : D(fig[i][j], fig[i + 1][j    ]) > SQR(TOL))
            && (i == N - 1 ? 1 : D(fig[i][j], fig[i + 1][j + 1]) > SQR(TOL))
            && iUnique(fig, N, M, i, j))
            {
                count++;
                N0 = i;
                M0 = j;
            }
    
    if(count == 0)  printf("Not Exist");
    if(count == 1)  printf("(%d, %d): %d", M0 + 1, N0 + 1, fig[N0][M0]);
    if(count >= 2)  printf("Not Unique");

    return 0;
}

```